<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="../styles/style.css" /><title>A static site generator in lambda calculus with effect handlers</title></head><body><p><a href="..#notes">Notes</a><br />2025/03/08</p><h1>A static site generator in lambda calculus with effect handlers</h1><p>How much must be added to a <a href="./2025-03-01.html">minimal language</a> like lambda calculus to write practical programs in it, such as a static site generator? Turns out, not much, if you add data types and more importantly, <em>effects and effect handlers</em>.</p><p>A simple static site generator written in such a minimal language comes in at around 150 lines, with IO such as reading and writing files implemented as effects that are handled by a host language (in this case Rust), turning Markdown such as...</p><pre><code># Blog Post

This is a paragraph with _emphasized_ text.
</code></pre><p>...into HTML such as...</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot; /&gt;
&lt;title&gt;Blog Post&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;styles/style.css&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Blog Post&lt;/h1&gt;
&lt;p&gt;This is a paragraph with &lt;em&gt;emphasized&lt;/em&gt; text.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2>Kombucha: lambda calculus + data + effects</h2><p>Here's the grammar for the language, dubbed <code>Kombucha</code> (with syntax examples below). Variables are identifiers starting with a lowercase letter and ending with <code>!</code> (like foo, foo-bar, fooBar), tags are identifiers starting with an uppercase letter or enclosed in quotation marks (like Foo, "some string"), and effects are identifiers that end with <code>!</code> (like print!, read-char!).</p><pre><code>t = var                        // variable
  | var &quot;=&gt;&quot; t                 // abstraction
  | t &quot;(&quot; t &quot;)&quot;                // application
  | tag                        // tag
  | &quot;if&quot; t &quot;is&quot; pat t &quot;else&quot; t // conditional
  | var &quot;~&gt;&quot; t                 // recursion
  | eff                        // effect
  | &quot;try&quot; t catch              // handler

pat = tag
    | pat &quot;(&quot; var &quot;)&quot; // must be distinct (!) vars

catch = &quot;&quot;
      | &quot;catch&quot; pat &quot;as&quot; var t catch
</code></pre><p>The first three constructs (variables, abstractions and applications) are standard lambda calculus, just using a more familiar JS-like notation:</p><pre><code>foo           // a variable
foo(bar)      // calling the function foo with argument bar
foo(bar, baz) // sugar for foo(bar)(baz)
foo =&gt; bar    // a function with argument foo and body bar

// let is sugar for (foo =&gt; baz)(bar)
let foo = bar
baz

// () is sugar for the empty tag &quot;&quot;,
// foo() is sugar for foo(&quot;&quot;)
foo()
</code></pre><p>The next two constructs (tags and conditionals) add data to the language and allow us to match on it. Tags just stand for themselves and are basically interned strings (but without any string operations on them, the only thing you can do with them is compare them for equality using if-else). To build up data structures, tags are applied to other values. For example, <code>Pair(x, y)</code> is the tag <code>Pair</code> applied first to x, then to y.</p><pre><code>let first = p =&gt;
  if p is Pair(x, y)
    x
  else
    Error

first(Pair(Foo, Bar)) // == Foo
</code></pre><p>Another construct (recursion) adds named recursion to the language, making implicit recursion via fixed-point combinators unnecessary. It can be used to build either recursive functions or recursive values:</p><pre><code>r ~&gt; Cons(Foo, r)
// == Cons(Foo, r ~&gt; Cons(Foo, r))
// == Cons(Foo, Cons(Foo, r ~&gt; Cons(Foo, r)))
// == ...

// &quot;loop&quot; is a recursive version of &quot;let&quot;,
// in other words it&apos;s sugar for (foo =&gt; baz)(foo ~&gt; bar)
loop foo = bar // bar can call foo recursively
baz
</code></pre><p>Putting this all together, here's how the classic map function can be defined:</p><pre><code>loop map = f =&gt; xs =&gt;
  if xs is Cons(x, xs)
    Cons(f(x), map(f, xs))
  else
    xs

map(
    x =&gt; Foo(x),
    Cons(Bar, Cons(Baz, Nil))
) // == Cons(Foo(Bar), Cons(Foo(Baz), Nil))
</code></pre><h2>Effects + effect handlers</h2><p>Now for the interesting part, effects and how to handle them! Effects work just like normal functions, except that their names end with <code>!</code> and that they are <em>dynamically bound:</em> It is not necessary to define what the effect <code>foo!</code> does in the code before using it, it can be supplied later. Effect handlers provide this late-binding, they catch an effect, capture the computation that called the effect and can resume it with a value:</p><pre><code>let twice = x =&gt; pair!(x, x)

try
  Foo(twice(Bar))
catch pair!(x, y) as resume
  resume(Pair(x, y)) // == Foo(Pair(Bar, Bar))
</code></pre><p>An effect handler does not need to resume the computation though, in which case such a handler acts more like an exception handler:</p><pre><code>let twice = x =&gt; pair!(x, x)

try
  Foo(twice(Bar))
catch pair!(x, y) as _
  BailingOut // == BailingOut
</code></pre><p>The possibility to resume existing computations makes effect handlers quite flexible, they can for example be used to build an effect that works like a stateful variable with getter and setter:</p><pre><code>loop with-state = val =&gt; f =&gt;
  try
    f()
  catch get!() as resume
    resume(val)
  catch set!(x) as resume
    with-state(x, _ =&gt; resume())

with-state(
  (),
  _ =&gt; List(
    get!(),
    set!(Foo),
    get!(),
    set!(Bar),
    set!(Baz),
    get!()
  )
) // == List((), (), Foo, (), (), Baz)
</code></pre><p>What happens when a program uses an effect but there is no handler defined? Execution will stop and return back to the host language that called the evaluator, in this case Rust, which is then free to handle the effect and can decide whether or not to resume the computation with a value.</p><p>This is a surprisingly powerful combination, because it keeps the embedded language simple, leading to an almost <em>symbiotic</em> relationship between host and embedded language: The embedded language can always use effects as an escape hatch and ask the host to handle things like IO.</p><p>For reference, <a href="https://gist.github.com/fkettelhoit/ec640ffcddc4cb4ec6b1af362d8f8a28">here's the Kombucha program</a> that converts a Markdown subset (of headings, emphasized text and code blocks) into HTML. It relies on two effects, "read-char!", to read a single char as a tag, and "write-strs!", to write a cons-list of tags to a file. It is definitely not the most ergonomic language, nesting if-else blocks leads to very verbose code, for example. But considering that the language does not provide much more than lambda calculus and has no standard library at all, the ease of programming in it is quite surprising.</p><h2>Observations</h2><p>While the language might be an interesting starting point, there are a couple of things that need to be fixed:</p><ul><li>The evaluator quickly overflows the stack, because evaluation works recursively, which doesn't play well with building up huge cons lists. Moving away from a tree-walk interpreter and towards a bytecode VM would solve this.</li><li>To stay close to the semantics of how functions are called in lambda calculus (without arity, multiple arguments need to be implemented using currying), effects likewise do not have a fixed arity, even though the handler syntax suggests so. In other words, a handler like <code>catch foo!(x) as ...</code> and a handler like <code>catch foo!(x, y) as ...</code> will catch the same effect <code>foo!</code>, the second handler will simply return a curried function until it gets its second argument. It would be nice to have handlers with a fixed arity, so that the same name can be overloaded with different implementations, but then handlers would work differently from normal functions.</li><li>An embarrassing oversight, but while writing the Kombucha static site generator I noticed that there's currently no way to check whether two variables x and y are the same tag Foo, because the pattern in an if-else expression needs to be static. So, another construct for comparing tags is necessary, but I would like to avoid adding equality for nested data because that would take the calculus away from its minimal tendencies.</li></ul><p>I'll revisit these as the language evolves.</p><footer>Want to become a better programmer? <a href="https://www.recurse.com/scout/click?t=764048f99cede394c1905c64e1545a5d">Join the Recurse Center!</a></footer></body></html>