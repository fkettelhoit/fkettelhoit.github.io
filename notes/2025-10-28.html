<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="../styles/style.css" /><title>RC week 22: paradoxical values as unordered time loop maps</title></head><body><p><a href="..#notes">Notes</a><br />2025/10/28</p><h1>RC week 22: paradoxical values as unordered time loop maps</h1><p>This continues the exploration from <a href="./2025-09-13.html">week 18</a> and <a href="./2025-09-20.html">week 19</a> about a calculus for dealing with paradoxical fixed points. The previous approach used ordered sequences with explicit step counters and phases to manage shifts. This week, I've simplified the design by switching to <strong>unordered maps</strong> that track relationships between values rather than temporal sequences.</p><h2>The map-based approach</h2><p>Instead of representing a time loop as an ordered sequence like <code>['x'; 'y']</code>, the new implementation uses a map structure that represents the relationships between values. The simple liar paradox is now represented as <code>('x' & 'y')</code>, which conceptually means “a value that oscillates between <code>'x'</code> and <code>'y'</code>”, in other words, a value that is <strong>both</strong> <code>'x'</code> <strong>and</strong> <code>'y'</code>.</p><p>Internally, this is stored as a <strong>time loop map:</strong> <code>('x': 'x', 'y': 'y')</code>. This might look redundant at first. After all, why map each value to itself? This will become clear when we look at nested examples, because associating values with their <em>origins</em> is crucial for reasoning about paradoxical sub-expressions.</p><h2>How to read time loop maps</h2><p>Before diving into examples, let's clarify the notation:</p><ul><li><code>('x' & 'y')</code> is shorthand for the time loop map <code>('x': 'x', 'y': 'y')</code></li><li>A map like <code>('x': 'y', 'y': 'x')</code> shows transformations: the key <code>'x'</code> produces the value <code>'y'</code>, and the key <code>'y'</code> produces the value <code>'x'</code></li><li>When all keys equal their corresponding values after normalization (like <code>('x': 'x', 'y': 'y')</code>), we have a fixed point</li><li>A normal value like <code>'x'</code> has no map structure—it's just <code>'x'</code></li></ul><p>The keys track where each value came from, which is crucial for reasoning about how values transform through function application.</p><h2>The simple liar and normalization</h2><p>Let's trace through the simple liar's paradox to see how the map-based approach works:</p><pre><code>v = (&apos;x&apos; &amp; &apos;y&apos;)
if v == &apos;x&apos;:
    &apos;y&apos;
else:
    &apos;x&apos;
</code></pre><p>When we compare a time loop to a regular value, we lift the comparison across all entries in the map. Using Church encoding where <code>true = (x, y) => x</code> and <code>false = (x, y) => y</code>, the comparison <code>('x' & 'y') == 'x'</code> evaluates to:</p><pre><code>(&apos;x&apos;: &apos;x&apos; == &apos;x&apos;, &apos;y&apos;: &apos;y&apos; == &apos;x&apos;)
</code></pre><p>...which evaluates to:</p><pre><code>(&apos;x&apos;: true, &apos;y&apos;: false)
</code></pre><p>When this map of booleans is applied to the two branches <code>'y'</code> and <code>'x'</code>, each function selects the appropriate branch:</p><ul><li>For key <code>'x'</code>: <code>true('y', 'x')</code> selects <code>'y'</code></li><li>For key <code>'y'</code>: <code>false('y', 'x')</code> selects <code>'x'</code></li></ul><p>This gives us <code>('x': 'y', 'y': 'x')</code> as the intermediate result. Notice how the keys track where each result came from: the <code>'x'</code> case produced <code>'y'</code>, and the <code>'y'</code> case produced <code>'x'</code>. This is why the map structure associates values with their <strong>origins</strong>—it's crucial for tracking transformations.</p><p>But we're not done yet. The key insight is <strong>normalization</strong>. After evaluating an expression, we check whether the resulting map represents a loop back to the original values. We simply check whether the keys and values of the map are the same set—just potentially reordered.</p><p>For our simple liar, we have <code>('x': 'y', 'y': 'x')</code>. The normalization process detects that this is a loop: the set <code>{'x', 'y'}</code> appears as both keys and values. When a loop is detected, the map is transformed so each key maps to itself: <code>('x': 'x', 'y': 'y')</code>, which is just <code>('x' & 'y')</code>.</p><p>This normalized form means we're back where we started—giving us a true fixed point for <code>v</code>.</p><h2>Rank-based lifting</h2><p>Like the sequential approach, the map-based approach uses a notion of "rank" (or depth) to handle nested time loops. A regular value has rank 0, a simple time loop like <code>('x' & 'y')</code> has rank 1, and a nested time loop has rank 2 or higher.</p><p>When comparing two time loop maps of the same rank, we zip them together key by key. When comparing values of different ranks, the lower-rank value is lifted into the structure of the higher-rank value. This ensures compositional reasoning about nested paradoxes.</p><p>Now that we've seen the basic mechanism, let's explore what happens when we compare against a time loop instead of a simple value.</p><h2>The captured liar</h2><pre><code>v = (&apos;y&apos; &amp; (&apos;x&apos; &amp; &apos;y&apos;))
if v == (&apos;x&apos; &amp; &apos;y&apos;):
    &apos;y&apos;
else:
    &apos;x&apos;
</code></pre><p>The left side has rank 2, the right side has rank 1. We lift the right side and compare each entry:</p><ul><li><code>'y'</code> compared to <code>('x' & 'y')</code> produces <code>('x': false, 'y': true)</code></li><li><code>('x' & 'y')</code> compared to <code>('x' & 'y')</code> produces <code>('x': true, 'y': true)</code>, which simplifies to just <code>true</code></li></ul><p>This gives us a nested structure: <code>('y': ('x': false, 'y': true), ('x' & 'y'): true)</code>. We can now apply this to the branches:</p><ul><li>For the <code>'y'</code> key: <code>('x': false, 'y': true)</code> applied to <code>('y', 'x')</code> gives <code>('x': 'x', 'y': 'y')</code></li><li>For the <code>('x' & 'y')</code> key: <code>true</code> applied to <code>('y', 'x')</code> gives <code>'y'</code></li></ul><p>This produces <code>('y': ('x': 'x', 'y': 'y'), ('x' & 'y'): 'y')</code>, which is equivalent to <code>('y': ('x' & 'y'), ('x' & 'y'): 'y')</code>. After normalization, each key maps back to itself, <code>('y': 'y', ('x' & 'y'): ('x' & 'y'))</code>, giving us our original value <code>v</code>, <code>('y' & ('x' & 'y'))</code>.</p><h2>The escaped liar</h2><p>This example shows how nested conditionals interact with time loops:</p><pre><code>v = (&apos;x&apos; &amp; (&apos;x&apos; &amp; &apos;y&apos;))
if v == (&apos;x&apos; &amp; &apos;y&apos;):
    &apos;x&apos;
else:
    if v == &apos;x&apos;:
        &apos;y&apos;
    else:
        &apos;x&apos;
</code></pre><p>Following the same pattern of rank-based lifting and evaluation, the outer comparison produces <code>('x': ('x': true, 'y': false), ('x' & 'y'): true)</code>, and the inner comparison produces <code>('x': true, ('x' & 'y'): ('x': true, 'y': false))</code>.</p><p>The inner conditional evaluates to <code>('x': 'y', ('x' & 'y'): ('x': 'y', 'y': 'x'))</code>.</p><p>The outer conditional then selects between <code>'x'</code> and the inner result, which is zipped together with the outer map:</p><ul><li>For the <code>'x'</code> key: the boolean map <code>('x': true, 'y': false)</code> selects between <code>'x'</code> and <code>'y'</code>, giving <code>('x': 'x', 'y': 'y')</code></li><li>For the <code>('x' & 'y')</code> key: <code>true</code> selects <code>'x'</code> without needing to look at the inner conditional</li></ul><p>After normalization, we get back <code>('x' & ('x' & 'y'))</code>.</p><h2>The liar's twin</h2><p>This example demonstrates compositional reasoning:</p><pre><code>v = (&apos;x&apos; &amp; &apos;y&apos;)
if v == &apos;x&apos;:
    &apos;y&apos;
else:
    if v == &apos;x&apos;:
        &apos;z&apos;
    else:
        &apos;x&apos;
</code></pre><p>Even though <code>('x' & 'y')</code> appears twice as <code>v</code>, the synchronized evaluation ensures consistent behavior. Both comparisons produce the same map <code>('x': true, 'y': false)</code>:</p><ul><li>For the <code>'x'</code> key: both conditionals see <code>true</code>, so we take the outer then-branch, returning <code>'y'</code></li><li>For the <code>'y'</code> key: both conditionals see <code>false</code>, so we take the outer else-branch, then the inner else-branch, returning <code>'x'</code></li></ul><p>The result is <code>('x': 'y', 'y': 'x')</code>, which normalizes to <code>('x': 'x', 'y': 'y')</code>. The middle branch (inner then-branch returning <code>'z'</code>) is never visited because the conditions are synchronized by zipping together the inner and outer conditionals via their keys.</p><h2>Why maps instead of sequences?</h2><p>The map-based approach eliminates the need to track explicit step counters and phases. Instead of thinking about "time step 0" versus "time step 1," we think about the relationships between values: when we have <code>'x'</code>, we get <code>'y'</code>, and when we have <code>'y'</code>, we get <code>'x'</code>.</p><p>The normalization process automatically detects when we've completed a cycle and returned to the original configuration. This makes the semantics simpler and more declarative—we're describing relationships rather than sequences of operations.</p><p>The unordered nature of maps also makes it clearer that time loops aren't lists or sequences that can be indexed or iterated through. They're genuinely oscillating values that exist in a superposition of states, with the map structure tracking how those states relate to each other.</p><h2>Technical detail: simplification</h2><p>The implementation includes a <code>simplify</code> function that collapses trivial time loops. If all values in a map are identical, the map is replaced by that single value. For example, <code>('x': true, 'y': true)</code> simplifies to just <code>true</code>. This effectively collapses a time loop where all possibilities lead to the same outcome.</p><p>This simplification happens recursively, so nested structures like <code>('a': ('x': 'foo', 'y': 'foo'), 'b': ('z': 'foo'))</code> would simplify to <code>('a': 'foo', 'b': 'foo')</code>, which further simplifies to just <code>'foo'</code>. This process happens automatically during evaluation and is particularly important for cleaning up boolean maps before they're used in conditionals.</p><h2>Looking forward</h2><p>The map-based representation provides a cleaner foundation for the time loop calculus. The absence of explicit shifting operations makes the evaluation rules more straightforward, and the normalization process naturally identifies fixed points.</p><p>Future work might explore whether this map-based approach can be extended to handle more complex forms of self-reference, such as monotonically growing fixed points of the form <code>x -> x + 1</code>. The rank-based lifting already provides a foundation for nested paradoxes, but there may be other patterns that require additional machinery.</p><p>Another obvious next step is to work on an actual decision procedure for deriving paradoxical fixed points, which should be possible at least for the finitely paradoxical fixed points discussed here.</p><footer>Want to become a better programmer? <a href="https://www.recurse.com/scout/click?t=764048f99cede394c1905c64e1545a5d">Join the Recurse Center!</a></footer></body></html>