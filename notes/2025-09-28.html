<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="../styles/style.css" /><title>RC week 19: a sketch for a time loop calculus, part 2</title></head><body><p><a href="..#notes">Notes</a><br />2025/09/28</p><h1>RC week 19: a sketch for a time loop calculus, part 2</h1><p>This continues the exploration from <a href="./2025-09-27.html">last week</a> about a calculus for dealing with paradoxical solutions for recursive loops. This week's note focuses on how time loops are shifted to achieve true fixed points and walks through a few concrete examples of paradoxical solutions.</p><h2>The shifting mechanism</h2><p>Last week's sketch left us with an important gap: our proposed time loops weren't quite fixed points because function application would shift them. <code>['x'; 'y']</code> would become <code>['y'; 'x']</code> after applying our liar function, giving us the right pattern but shifted by one position.</p><p>The key insight is that time loops need to track both their current <em>step</em> and their <em>phase</em>. Each time the time loop is applied to a value, it counts as a <em>step</em>. The <em>phase</em> is fixed and specifies after how many steps a time loop is shifted by one position. The notation <code>['x'; 'y']@0/2</code> represents a time loop at step 0 with a phase of 2.</p><p>Concretely, shifts can happen when a time loop is used as an argument or as a function:</p><ul><li>When a time loop with a non-zero phase is used as an argument, it gets rotated left by one position and its step is set to the phase value.</li><li>When a time loop is applied to an argument, the step counter increments, and when the step counter equals the phase, the result gets rotated right, and the step counter resets to 0.</li></ul><p>“Normal” values have a phase of 0, which just means that they are never shifted in either direction. If the phase is 0, the step-and-phase annotation is omitted.</p><p>This shifting mechanism ensures that after a complete function application cycle, we get back to the original time loop configuration, returning true fixed points rather than shifted versions.</p><p>Let's examine how this works with concrete examples from our implementation.</p><h2>The simple liar</h2><pre><code>if [&apos;x&apos;; &apos;y&apos;]@0/2 == &apos;x&apos;:
    &apos;y&apos;
else:
    &apos;x&apos;
</code></pre><p>The time loop <code>['x'; 'y']@0/2</code> represents our paradoxical value. At step 0, it's <code>'x'</code>, so the comparison <code>['x'; 'y'] == 'x'</code> evaluates to <code>[true; false]@0/2</code>. The conditional then applies the time loop to two arguments, which increments the step counter twice and returns <code>'y'</code> for the first case and <code>'x'</code> for the second, giving us <code>['y'; 'x']@2/2</code>. After shifting, this becomes <code>['x'; 'y']@0/2</code> again, which is what we started with and thus a fixed point.</p><h2>The captured liar</h2><pre><code>if [[&apos;x&apos;]; [&apos;y&apos;; &apos;x&apos;]]@0/2 == [&apos;x&apos;; &apos;y&apos;]:
    &apos;y&apos;
else:
    &apos;x&apos;
</code></pre><p>Here we have a depth-2 time loop being compared to a depth-1 time loop. Since the depths differ, the comparison lifts the smaller depth value. The first element <code>['x']</code> gets compared to the entire <code>['x'; 'y']</code>, yielding <code>[true; false]</code>. The second element <code>['y'; 'x']</code> also gets compared to <code>['x'; 'y']</code>, yielding <code>[false; false]</code>. This gives us the nested boolean <code>[[true; false]; [false; false]]@0/2</code>, which simplifies to <code>[[true; false]; [false]]@0/2</code>.</p><p>The conditional then applies this time loop to the arguments <code>'y'</code> and <code>'x'</code>. After two applications, the step counter reaches 2, returning <code>[['y'; 'x']; ['x']]@2/2</code>. Since step equals phase, this triggers a shift that rotates the result and resets to step 0, giving us our original <code>[['x']; ['y'; 'x']]@0/2</code>.</p><h2>The escaped liar</h2><pre><code>if [[&apos;x&apos;]; [&apos;x&apos;; &apos;y&apos;]]@0/2 == [&apos;x&apos;; &apos;y&apos;]:
    &apos;x&apos;
else:
    if [[&apos;x&apos;]; [&apos;x&apos;; &apos;y&apos;]]@0/2 == &apos;x&apos;:
        &apos;y&apos;
    else:
        &apos;x&apos;
</code></pre><p>This example shows how nested conditionals can “escape” certain paradoxical patterns. At the first level, <code>['x']</code> compared to <code>['x'; 'y']</code> gives <code>[true; false]</code>, while <code>['x'; 'y']</code> compared to <code>['x'; 'y']</code> gives <code>[true; true]</code>. The outer condition evaluates to <code>[[true; false]; [true]]@0/2</code>, selecting <code>'x'</code> in the <code>true</code> case and entering the inner conditional in the <code>false</code> case.</p><p>The comparison of the inner conditional evaluates to <code>[[true]; [true; false]]@0/2</code>, which is applied to the two arguments <code>'y'</code> and <code>'x'</code>, leading to <code>[['y']; ['y'; 'x']]@2/2</code>. This is now shifted, so that the inner conditional evaluates to <code>[['y'; 'x']; ['y']]@0/2</code>.</p><p>When the value <code>[[true; false]; [true]]@0/2</code> from the outer conditional is applied to the evaluated result of the inner conditional, the inner conditional is shifted back (because it is used as an argument), so that <code>[[true; false]; [true]]@0/2</code> is zipped together with <code>x</code> (from the outer then-branch) and <code>[['y']; ['y'; 'x']]@2/2</code>, evaluating to <code>[[true('x', 'y'); false('x', 'y')]; [true('x', 'x')]]@2/2</code>, which finally evaluates to the shifted value <code>[['x']; ['x'; 'y']]@0/2</code>.</p><p>The synchronization of time steps ensures that the inner conditional is only visited when the outer condition is false, preventing any interference between the nested paradoxes.</p><h2>The liar's twin</h2><pre><code>if [&apos;x&apos;; &apos;y&apos;]@0/2 == &apos;x&apos;:
    &apos;y&apos;
else:
    if [&apos;x&apos;; &apos;y&apos;]@0/2 == &apos;x&apos;:
        &apos;y&apos;
    else:
        &apos;x&apos;
</code></pre><p>This demonstrates the compositional nature of time loops. Even though the same time loop <code>['x'; 'y']@0/2</code> appears in multiple places, the synchronized time steps ensure consistent behavior. At step 0 (when the value is <code>'x'</code>), both comparisons yield <code>true</code>, so only the outer then-branch executes, returning <code>'y'</code>. At step 1 (when the value is <code>'y'</code>), both comparisons yield <code>false</code>, so we enter the outer else-branch and then the inner else-branch, returning <code>'x'</code>.</p><p>The result is <code>['y'; 'x']@2/2</code>, which after shifting becomes <code>['x'; 'y']@0/2</code>, which is exactly what we started with. The middle branch (inner then-branch) is never visited because the conditions are always synchronized.</p><h2>Looking forward</h2><p>The time loop calculus provides a systematic way to reason about paradoxical fixed points while maintaining compositional semantics. The shifting mechanism ensures that we get true fixed points rather than approximate ones, and the depth-based lifting rules allow us to combine different paradoxical subexpressions without interference.</p><p>The synchronization of time steps across all uses of a time loop value allows us to analyze complex nested conditionals by considering each time step independently, then combining the results into a unified time loop solution.</p><p>Future work might explore how this approach scales to more complex programming constructs and whether similar techniques can be applied to other forms of self-reference beyond the boolean paradoxes examined here.</p><footer>Want to become a better programmer? <a href="https://www.recurse.com/scout/click?t=764048f99cede394c1905c64e1545a5d">Join the Recurse Center!</a></footer></body></html>