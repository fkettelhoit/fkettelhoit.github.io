<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="../styles/style.css" /><title>Why don&apos;t functional languages expose boxing, layout, and ownership?</title></head><body><p><a href="..#notes">Notes</a><br />2026/01/17</p><h1>Why don't functional languages expose boxing, layout, and ownership?</h1><p>What are the most fundamental ways of representing data in a minimal programming language? Let's assume a language with some model of computation (such as lambda calculus functions and variables), what are the most minimal ways to extend it so that we can specify arbitrary data types?</p><p>There is of course the option of sidestepping the issue and pretending that computation and data are the same thing. This is what pure lambda calculus does. Another option is to add a single collection type to the language and build everything else out of it, for example using cons lists in Lisp, or using objects in a minimal OOP language like Self. Both of these options are quite abstract and hard to map to an efficient abstract machine model.</p><p>Two other well-known options, which allow us to specify new types using low level data type <em>definitions</em>, are ML-style data types and C's combination of unions and structs. Apart from C's unions being untagged (and thus allowing for some unsafe shenanigans), these are conceptually pretty similar, because they allow us to encode sum types (variants of a data type in ML-style languages, tagged unions in C) and product types (fields of a data type in ML-style languages, structs in C).</p><p>But where they differ is that C's abstract machine model exposes additional distinctions that ML-style data types abstract away. What are these distinctions? And would it be possible to build a functional language with an ML-like feel that exposes these distinctions?</p><h2>Boxed vs. unboxed</h2><p>The most glaring difference between ML and C is that C gives us control over when data is allocated “boxed” on the heap vs. “unboxed” on the stack, by exposing pointers as part of the language. In ML-style languages, the decision of whether to box or unbox values is not exposed: Values could be kept unboxed for data type definitions that are small enough or don't have parameters, or boxed if the compiler decides so.</p><h2>Nested vs. contiguous</h2><p>The only way to build a list-like data structure out of data type definitions (in the absence of other collection types) is to <em>recursively nest</em> data types, such as using cons lists or trees. This is possible in C as well, but C also provides <em>arrays</em> and thus a <em>contiguous</em> way of storing sequential data. ML-style data types and C-style structs are <em>tuples</em>, which can pack heterogeneous data together, whereas C arrays contain homogenous data in the form of elements of the same size.</p><h2>Shared vs. owned</h2><p>In the purely functional subset of ML-style languages with data types definitions, all values are shared and no operation destructively mutates them. In C, direct mutation is possible. From the perspective of a functional programmer, this comes with a wealth of problems, but it also makes C flexible enough to serve as a compilation target for languages that distinguish data with a single owner (thus allowing safe mutation) from data with multiple references to it (where mutation would thus have observable side effects).</p><h2>Untangling these distinctions</h2><p>Traditionally, languages have presented these three distinctions as intimately linked: Either we have C's free for all with all the implications of unsafety that C brings with it, or the choice has been made for us and the three distinctions are rolled together, in the form of persistent data types in purely functional languages, which are boxed, nested and shared.</p><p>But as more recent languages such as Rust have demonstrated, these distinctions can be untangled without necessarily introducing C-style unsafety. Rust exposes all of the above distinctions, at the cost of requiring a borrow checker and rejecting some valid programs.</p><p>It's possible to untangle these distinctions even in the absence of Rust-style static borrow checking. Koka's <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2020/11/perceus-tr-v1.pdf">Perceus</a> reference counting mutates values with a single owner, while sharing values with multiple references to it, based on runtime semantics, so that the same algorithm can be used for both owned and shared data. <a href="https://www.jot.fm/issues/issue_2022_02/article2.pdf">Mutable Value Semantics</a> is another approach that uses copying instead of sharing when multiple references are involved.</p><p>In a functional language, the above distinctions could be fully independent while relying purely on runtime checks:</p><ul><li>The distinction between boxed and unboxed data translates to a tradeoff between more pointer chasing (in the case of excessive boxing) and more data to move around (in the case of excessive unboxing).</li><li>The distinction between nested and contiguous data translates to a tradeoff between treating data as composed of smaller parts (for nested data, making it easier to mutate/share substructures) and treating data as a homogenous collection (for contiguous data, making random access/mutation more efficient).</li><li>The distinction between owned and shared data translates to a tradeoff between having to copy data on read (for owned data, to guarantee single ownership) and having to copy data on write (for shared data).</li></ul><p>The distinction between owned and shared data can either be tracked statically (using linear types / borrowing like in Rust) or dynamically at run-time (like in Koka/Perceus and MVS).</p><p>Koka/Perceus and MVS each go beyond an ML-style model by building on the distinction between owned and shared data, but without exposing that distinction as user-level annotations and static checks. Instead, algorithms are polymorphic over owned/shared data and mutate in place when possible. Koka/Perceus is (mainly) built on boxed and nested data, whereas MVS is (mainly) built on boxed and contiguous data. Neither of them make it possible to mix and match between the two approaches, nor do they make it possible to keep all data unboxed.</p><p>What would such a language look like? Hard to say. No existing language seems to expose all three distinctions independently while maintaining functional semantics. The design space remains largely unexplored.</p><p>A functional language that exposed all of these distinctions would let programmers choose: boxing for indirection, contiguous data for cache locality, and ownership for safe mutation. Each choice independent, each with clear tradeoffs, none privileged by the language designer's assumptions about what matters most.</p><footer>Want to become a better programmer? <a href="https://www.recurse.com/scout/click?t=764048f99cede394c1905c64e1545a5d">Join the Recurse Center!</a></footer></body></html>