<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="../styles/style.css" /><title>RC week 16: The halting problem, time loops and paradoxes</title></head><body><p><a href="..#notes">Notes</a><br />2025/09/13</p><h1>RC week 16: The halting problem, time loops and paradoxes</h1><p>Here's a sketch for a two-player game: One person writes a function in a simple programming language with nothing but strings and if-then-else statements, the other person then looks at the program and has to come up with a value that, if used as the argument of the function, is also the return value of the function. If it's not possible to come up with such a value, the person who wrote the function wins.</p><p>For example, let's say player 1 came up with the following function:</p><pre><code>def f(x):
    if x == &quot;foo&quot;:
        &quot;bar&quot;
    else:
        &quot;baz&quot;
</code></pre><p>Now player 2 has to come up with a value <code>x</code> so that <code>x</code> is the same as <code>f(x)</code>. The value <code>"foo"</code> wouldn't work, because <code>f("foo")</code> is <code>"bar"</code>, but the value <code>"baz"</code> would work, because <code>f("baz")</code> returns <code>"baz"</code>.</p><p>Let's consider a more interesting case:</p><pre><code>def f(x):
    if x == &quot;foo&quot;:
        &quot;bar&quot;
    else:
        &quot;foo&quot;
</code></pre><p>Is it possible for player 2 to win the game by coming up with a value so that <code>x</code> is <code>f(x)</code>? It doesn't seem that way, because <code>f("foo")</code> returns <code>"bar"</code>, but <code>f("bar")</code> returns <code>"foo"</code>. In a way, the function is <em>adversarial,</em> because no matter whether player 2 picks <code>"foo"</code> or <code>"bar"</code> as their prediction, the function always returns exactly the other value.</p><h2>Turing's halting problem</h2><p>The last function is conceptually similar to the <a href="https://en.wikipedia.org/wiki/Halting_problem#Proof_concept">halting problem</a>. To show why there is no general algorithm that could decide whether an arbitrary function halts or loops forever, let's assume that we had a function <code>h</code> that takes another function <code>f</code> as its argument and returns <code>"halts"</code> if <code>f</code> halts and <code>"loops"</code> if <code>f</code> doesn't terminate. We could then write the following function:</p><pre><code>def f():
    if h(f) == &quot;halts&quot;:
        while true:
            # loop forever
    else:
        &quot;halts&quot;
</code></pre><p>The function <code>f</code> just does the opposite of what <code>h</code> predicts <code>f</code> will do: If <code>h(f)</code> predicts that <code>f</code> halts, it loops forever, otherwise it just terminates and returns the value <code>"halts"</code>. This contradicts our assumption that <code>h</code> is a general algorithm that decides correctly whether an arbitrary function halts, it follows that there can be no such function <code>h</code>, the halting problem is undecidable.</p><p>(The above is just a sketch of the proof, an actual proof usually proceeds by diagonalization, so that no explicit self-reference is necessary. Still, it uses the same principle of constructing a case that we could describe as similar to our adversarial <code>"foo"</code>/<code>"bar"</code> function above.)</p><h2>The grandfather paradox</h2><p>Making a prediction about a function that self-recursively refers to this very prediction leads to similar paradoxes as time travel, such as the <a href="https://en.wikipedia.org/wiki/Temporal_paradox#Consistency_paradox">grandfather paradox</a>:</p><blockquote>A common example given is a time traveler killing their grandfather before their parents' conception, thus preventing the conception of themselves. If the traveler were not born, they could not kill their grandfather; therefore, the grandfather proceeds to beget the traveler's ancestor who begets the traveler. This scenario is self-contradictory.</blockquote><p>If we squint a bit, we can view our prediction game as a game about time travel, because a winning value <code>x</code> must form a closed time loop in respect to <code>f</code> so that “sending” the value into the past and “through” <code>f</code> returns the same value <code>x</code> in the future.</p><p>The example function that returns <code>"bar"</code> if <code>x</code> is <code>"foo"</code> and else <code>"foo"</code> is thus similar to the grandfather paradox, because neither <code>"foo"</code> nor <code>"bar"</code> are valid predictions on their own. But could we change the rules of the language in such a way that a prediction is made possible?</p><h2>Embracing paradoxes</h2><p>Well, why not embrace the paradox and say that a valid prediction for <code>x</code> is <code>"foo"</code> <em>and</em> <code>"bar"</code>? Our prediction for <code>x</code> is, in other words, a value that is <em>both</em> <code>"foo"</code> and <code>"bar"</code> <em>at the same time,</em> written as <code>"foo" & "bar"</code>. We will call <code>&</code> a “paradoxical and”, not to be confused with the boolean and that most languages provide.</p><p>When a paradoxical value is involved in a comparison such as <code>("foo" & "bar") == "foo"</code>, the if-then-else construct returns the result of evaluating <em>both</em> branches connected as a paradoxical <code>&</code>:</p><pre><code>// evaluates to `&quot;foo&quot; &amp; &quot;bar&quot;`
if (&quot;foo&quot; &amp; &quot;bar&quot;) == &quot;foo&quot;:
    &quot;bar&quot;
else:
    &quot;foo&quot;
</code></pre><p>This brings us to the real point of the prediction game: Player 1 still needs to come up with a function for which player 2 has to find a value so that <code>x</code> equals <code>f(x)</code>, but player 2 can now extend the rules of the language at the beginning of the game, by for example adding a construct like the paradoxical <code>&</code> operator and fully specifying how it behaves.</p><p>The new rules must be <em>extensions:</em> Player 1 must still be able to write normal functions that do not use any paradoxical operators, but player 2 is free to make predictions that involve paradoxical values using the rules that have been determined at the beginning of the game. Similarly, player 2 is free to use paradoxical values and operators when writing the function.</p><p>Coming up with good rules is harder than it looks, because if player 1 is free to use paradoxical values while writing their function, they can try to block paradoxical predictions by simply returning normal values in such a case:</p><pre><code>def f(x):
    if x == (&quot;foo&quot; &amp; &quot;bar&quot;):
        &quot;bar&quot;
    else:
        &quot;foo&quot;
</code></pre><p>Is it possible to come up with a language that makes it possible for player 2 to <em>always</em> make a valid prediction, no matter which function player 1 comes up with? To design a language that can express the fixed point where <code>x</code> is <code>f(x)</code> as a value for arbitrary functions, even if that value might necessarily be paradoxical?</p><h2>Recursion</h2><p>One last note on recursion, because all of the previous examples have been expressed in terms of a function with one argument and the goal of the game was to find the fixed point, in other words, the value where <code>x</code> equals <code>f(x)</code>. All of the previous examples could also have been defined directly using recursion, as follows:</p><pre><code>def f():
    if f() == &quot;foo&quot;:
        &quot;bar&quot;
    else:
        &quot;baz&quot;
</code></pre><p>This makes it easier to see the parallels with time loops and time travel, because <code>f()</code> clearly loops! But that's also the problem, because we're so used to thinking about <code>f()</code> as obviously never terminating that it's hard to even talk about what a value such as <code>"foo" & "bar"</code> could <em>mean</em> in this example.</p><p>So that's the point of stating it as a game. One that is superficially about taking turns and making predictions, but actually about recursion and how inconsistent solutions to fixed points could look like.</p></body></html>