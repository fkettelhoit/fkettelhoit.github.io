# RC week 1: Kombuchaâ€”a minimal and malleable language

This week marks my first week at the [Recurse Center](https://www.recurse.com/), where I got to meet a lot of amazing people and had a ton of interesting conversations. I didn't find a lot of time to work on my programming language, Kombucha, but I got the chance to talk about why I'm building a new language and realized that I'm bad at explaining it. So here's why:

I'm building a _minimal_ and _malleable_ language for _end-user programming._

In many ways, Kombucha is supposed to be the opposite of Rust: Kombucha is intended for _programming in the small_, for _incremental development_ with a _rapid feedback cycle_. It does not compete with Rust, but is meant to extend Rust _symbiotically_.

([Nick](https://nicknoble.works/) perfectly described it as "end-user programming for _Rustaceans_".)

## Minimal

Kombucha is minimal, in the sense that the language provides a small core which can then be extended. This applies both to the syntax and the semantics of the language: Kombucha's syntax is extremely small and regular, there are no built-in keywords or control structures with special syntax, even variable assignment is just a normal function. Kombucha is similar to Lisps in this regard, but Kombucha additionally provides some syntactic sugar that avoids Lisp's parentheses-heavy syntax.

```
// prefix function call
f(x, y)

// infix function call
x f y

// keyword function call
if: x is: y do: {
    ...
} else: {
    ...
}
```

## Malleable

Not having any privileged control structures or special keywords makes Kombucha _malleable:_ It is easy to make the language fit the problem domain. Even something as fundamental as pattern matching does not need to be built into Kombucha, because it can be defined as a function and then used like any other function.

```
'first('x, 'y) = {
  match: Pair(x, y) with: (
    Pair('x, 'y) -> { x }
    '_           -> { throw!("expected a pair!") }
  )
}

'x = Pair(Foo, Bar)

print!(first(x))
```

## Effectful

Any symbol ending with `!` is an _effect_, which can be handled using an _effect handler_. An effect is like an exception that is _resumable:_ Whenever an effect is called, it stops execution and walks up the call stack until it finds an effect handler that knows how to handle the effect. The effect handler can either abort the current execution (like an exception) or resume the execution with the result of the effect.

```
// foo does not care how the read! effect is handled:
'foo() = {
    'input = read!()
    match: input with: (
        Ok('contents) -> { contents }
        '_            -> { "" }
    )
}

// we can catch the effect and handle it:
try: {
    foo()
} catch: read! as: ('resume, 'arg) => {
    resume("TestInput")
}
```

## Symbiotic

Effects don't have to be handled inside of Kombucha, it is fine to just let an effect bubble up all the way to the Rust host, who can then handle it and resume the execution. This keeps Kombucha small, while also allowing it to easily hook into Rust's ecosystem.

```
// read! and print! will be handled by the Rust host:
'file = read!("foo.txt")
match: file with: (
  Ok('contents) -> { print!(contents) }
  Err('_)       -> { print!("Could not read file.") }
)
```

## Reasonable

Kombucha is in many ways a very dynamic language and built with a fast iteration speed in mind, but it also aims to be easy to _statically reason about,_ for both humans and compilers. Runtime reflection is limited by design and Kombucha explicitly distinguishes variables that are being _used_ from variables that are being _bound_ (which are prefixed with a single quote), which keeps Kombucha's macros easy to reason about.

```
// x is being bound, f and y are being used:
'x = f(y)

match: Pair(x, y) with: (
  Pair('_, z)  -> { "pair with z as second element" }
  Pair('_, '_) -> { "any pair" }
  '_           -> { "any value" }
)
```

## Reloadable

This goal is still aspirational (and one of the topics that I want to focus on at Recurse Center). One of the ideas behind Kombucha is to be able to develop and modify a whole application without once stopping a running program, while at the same time ensuring that the source code remains at all times the single source of truth. This last requirement makes it different from REPL-driven development, where it is easy to get into a state where the state of the REPL does not correspond to the definitions in the source file.

Let's see how far I get!
