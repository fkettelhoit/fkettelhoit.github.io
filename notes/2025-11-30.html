<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="../styles/style.css" /><title>Sketching out Kombucha&apos;s type system</title></head><body><p><a href="..#notes">Notes</a><br />2025/11/30</p><h1>Sketching out Kombucha's type system</h1><p>I've recently been thinking about how to add a type system to <a href="https://github.com/fkettelhoit/kombucha">Kombucha</a>. This has been on the roadmap for a while, even though Kombucha deliberately started its life as a dynamically typed language.</p><p>Type systems are notoriously hard to add to a language designed without types in mind, but Kombucha was also meant to feel very light on types and more like a dynamically typed language. Although the pendulum seems to be swinging back in the direction of static types, Kombucha has been very influenced by Clojure and shares Clojure's view that having static types is not a panacea but a tradeoff.</p><p>That being said, I've recently been able to clarify the tradeoffs that I want Kombucha to make and they all seem to point to a type system with the following characteristics.</p><h2>Explicit and implicit recursion</h2><p>The first reason for wanting a type system is both simple and somewhat unorthodox: I want to ensure that recursion is only possible by using Kombucha's fixed point operator (which is compiled to a special bytecode instruction), not by using implicit recursion, for example through manually constructing a fixed point combinator. A type system is simply the easiest and most boring way to reject implicitly/accidentally recursive programs.</p><p>The reason for wanting to reject implicit recursion is two-fold: First of all, I'm not aware of genuinely useful constructions that employ implicit recursion. It's mostly a neat trick, which ends up being much harder to read than using explicit recursion. This might be one of the areas where type systems offer a (very limited) benefit with (almost) no tradeoffs.</p><p>Secondly and more importantly, I'm interested in enforcing explicit recursion for implementation reasons: In the presence of partial evaluation, it's extremely helpful to know that unbounded recursion can only occur in the presence of the explicit fixed point operator, because then partial evaluation can evaluate these recursive operations up to a bounded limit.</p><h2>Structural types</h2><p>Types are more interesting from a non-implementation UX perspective though. Most static types systems for functional languages lean into algebraic data types that are explicitly declared and often <em>nominal</em> types where the same type definitions with different names are considered to be distinct types.</p><p>I want to explore how close Kombucha can get to feeling like a dynamically typed language while still providing some of the main benefits of a statically typed language. The aim isn't to provide perfect correctness through types, the aim is to get 80% of what static types normally provide while paying only 20% of the annoyance cost of most type systems.</p><p>This is why I want a type system that is <em>structural</em>, where two types are considered to be equal if they have the same structure. TypeScript gets this mostly right but ends up with an extremely complicated type system due to having to support anything that JavaScript can express. The basic idea, of leaning heavily on union and intersection types, seems extremely promising though.</p><h2>Type annotations and inference</h2><p>The next question is to which degree types should be inferred (instead of having to be explicitly annotated). Most new languages seem to have learned their lesson from Java and do not require every variable to be explicitly annotated. Full type inference, however, while being technically possible in systems such as Hindley-Milner or rank 2 intersection types, is hard to combine with other language features such as subtyping.</p><p>Annotating only function parameters and return types seems to be a good balance in practice. This is more challenging in Kombucha, which doesn't have a single privileged construct to create functions, but is still applicable if we require type annotations in all cases where bindings aren't immediately assigned values and would thus have redundant types. This then boils down to only annotating function parameters.</p><h2>Type aliases</h2><p>Once type annotations are introduced, especially in the presence of structural types with potentially large unions or intersections, it becomes annoying to repeat the same complicated type over and over again. Type aliases are an obvious solution, but they are non-trivial for two reasons:</p><ul><li>They introduce a mini-language that must be statically evaluated and thus cannot support the full power of the programming language that is to be typed. Compile time evaluation might be a way to use the full power of the object language as the meta language, but then type aliases only exist “before” type checking.</li><li>It is not immediately clear which type alias to pick when type errors are reported, because a structural type system could lead to a type <code>A | B | C</code> in the presence of the two aliases <code>T1 = A | B</code> and <code>T2 = B | C</code>. Should the type <code>A | B | C</code> be reported as is, or as <code>T1 | C</code>, or as <code>A | T2</code>?</li></ul><p>In Kombucha, which doesn't really have the notion of a “top level” block, there's also the issue of scope: If type aliases are supposed to mirror other definitions, they should only be valid within a scope. But then how are type aliases reported if some values with that type alias outlive the scope of the type alias? And where are type aliases allowed to be defined? Only as elements of <code>{ ... }</code> blocks?</p><h2>Types and macros</h2><p>There is an interesting way in which a type system could make Kombucha's existing syntax simpler: As part of its macro system, Kombucha syntactically distinguishes <em>bindings</em> (which are variables to be bound) from <em>values</em> (variables that are used):</p><pre><code>// `foo` is a binding, `bar` is a value
:foo = bar
</code></pre><p>This creates a lot of noise in Kombucha, because every binding needs to be explicitly marked as a variable-to-be by using the prefix colon notation. (Well, at least the bindings that are not immediately followed by a block. If one of the arguments of a macro is a raw block of the form <code>{ ... }</code>, the other arguments can be assumed to be bindings. More details <a href="../papers/reasonable-macros-through-explicit-bindings-v2.pdf">here</a>.)</p><p>Bindings are a natural place to put type annotations. In fact, it is fine to allow type annotations <em>only</em> after bindings, because all function parameters and variable definitions use bindings. This makes it possible to get rid of the prefix colon syntax and instead treat every identifier followed by a type annotation as a binding:</p><pre><code>// explicit bindings, untyped
:foo = &quot;Hello&quot;
:bar = &quot;World&quot;

// implicit bindings, typed
foo: string = &quot;Hello&quot;
bar: string = &quot;World&quot;
</code></pre><p>The big drawback is that this would be a throwback to Java days where each variable needs to be annotated. One option would be to use a special syntax to mark the variable type as inferred:</p><pre><code>// the types of `foo` and `bar` are inferred
foo: ? = &quot;Hello&quot;
bar: ? = &quot;World&quot;

// or even more succinctly:
foo? = &quot;Hello&quot;
bar? = &quot;World&quot;
</code></pre><p>But even this feels syntactically heavy. Additionally, Kombucha currently uses postfix colons for <a href="https://hexdocs.pm/elixir/keywords-and-maps.html">keyword lists</a> in function calls, which would conflict with postfix colons for type annotations.</p><p>These are just initial sketches of how a type system might fit into Kombucha's design philosophy. The challenge is finding the right balance between static guarantees and dynamic flexibility. But nobody said bolting a type system onto an existing language would be easy, did they?</p><footer>Want to become a better programmer? <a href="https://www.recurse.com/scout/click?t=764048f99cede394c1905c64e1545a5d">Join the Recurse Center!</a></footer></body></html>