<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="../styles/style.css" /><title>Trailing arguments, keyword arguments, infix grouping, and tuples</title></head><body><p><a href="..#notes">Notes</a><br />2026/01/28</p><h1>Trailing arguments, keyword arguments, infix grouping, and tuples</h1><p>I'm revisiting some of Kombucha's syntax. The goal is to have a syntax that is both minimal and general (in the sense that almost no syntax is privileged and everything is just a user-defined function) while also being less of a soup of parentheses than most Lisps are.</p><p>The basic idea is that...</p><ul><li>functions are prefix by default, like <code>foo(bar, baz)</code>,</li><li>but infix is allowed, like <code>((x * y) + z)</code> as long as parens are used to disambiguate,</li><li>(except for the same infix operators, like <code>x + y + z</code>, which don't need parens),</li><li>but there are also trailing arguments and keyword arguments for “core” constructs.</li></ul><p>The idea of minimal-but-general syntax and trailing arguments are borrowed from Koka (where you can write <code>foo { ... }</code> without needing to wrap the block as <code>foo({...})</code>), while keyword arguments such as <code>if (condition) do: { ... } else: { ... }</code> are borrowed from Elixir (via Ruby) and desugar to <code>if(condition, [["do", {...}], ["else", {...}]])</code>.</p><p>In Elixir, keywords such as <code>do:</code> and <code>else:</code> don't need postfix colons in most situations, which leads to pretty nice syntax, but raises the question of how to disambiguate a combination of infix calls and keyword arguments (in a language like Kombucha which doesn't restrict infix operators to a fixed set).</p><h2>Trailing arguments, keywords arguments</h2><p>Here are two options for keyword arguments:</p><pre><code>// Option 1: `:` for keywords, infix allowed after keywords
try {
    // ...
} catch: error! as: [resume, arg] =&gt; {
    // ...
}
</code></pre><p>vs.</p><pre><code>// Option 2: no `:` for keywords, no infix allowed after keywords
try {
    // ...
} catch error! as ([resume, arg] =&gt; {
    // ...
})
</code></pre><p>Advantages of keywords-with-colons:</p><ul><li>clear, explicit syntax even in unfamiliar contexts / DSLs</li><li>infix calls allowed as arguments without needing parens</li><li><code>key: value</code> syntax can be used as a general key-value syntax</li></ul><p>Advantages of keywords-without-colons:</p><ul><li>more familiar control structures (<code>do { ... } while { ... }</code>)</li><li><code>:</code> is exclusively used for other features such as type annotations</li><li>simple parser, because infix can never follow keyword calls</li></ul><p>Since being explicit about syntax and being able to use infix calls as keyword arguments is more important to me than sticking as closely as possible to existing language syntax, Kombucha is using option 1.</p><h2>Infix grouping, tuples</h2><p>Previously, Kombucha used <code>(x, y, ...)</code> exclusively for function arguments and a single expression like <code>(expression)</code> to disambiguate nested infix calls. In other words, <code>(expression)</code> was semantically the same as <code>expression</code>, and multiple items wrapped in parens were only allowed as function call syntax. A collection of values was always written as <code>[x, y, ...]</code>. As a result, function parameters in anonymous functions had to be wrapped in <code>[...]</code>, like <code>[x, y] => f(x, y)</code>.</p><p>But what if the language needs to support different kinds of sequential data, such as arrays of boxed elements (which thus each take up the same space in memory, allowing for O(1) access) as well as tuples of fields with differents lengths? What if we wanted to use <code>[...]</code> for arrays and <code>(...)</code> for tuples?</p><p>Rust uses <code>(...)</code> for both tuples and grouping, which works because <code>(x)</code> is not a tuple, it's the same as <code>x</code>. Single element tuples have to be written with a trailing <code>,</code> in Rust, like <code>(x,)</code>.</p><p>Here's another option for Kombucha: <em>Anything wrapped in `(...)` is always a tuple, except when it's used on the left or right hand side of an infix function and contains a single element</em>, in which case it's interpreted as parens meant to disambiguate. To use a single element tuple as an argument of an infix function, it needs to be wrapped in additional parens, like <code>((x)) f y</code>, which is the same as <code>f((x), y)</code>.</p><p>This also leads to a pleasant syntax for anonymous functions, because the <code>(x, y)</code> in <code>(x, y) => { ... }</code> is a two element tuple, whereas the <code>(x)</code> in <code>(x) => { ... }</code> can be simplified to <code>x => { ... }</code>, just like in JS.</p><p>Putting it all together (trailing arguments + keyword calls + infix calls + tuples):</p><pre><code>try {
    // ...
} catch: error! as: (resume, arg) =&gt; {
    // ...
}

if (x == y) {
    // ...
} elif: (x == z) do: {
    // ...
} else: {
    // ...
}

do {
    // ...
} while: { ... }

while { ... } {
    // ...
}
</code></pre><p>All while remaining minimal and general.</p><footer>Want to become a better programmer? <a href="https://www.recurse.com/scout/click?t=764048f99cede394c1905c64e1545a5d">Join the Recurse Center!</a></footer></body></html>