<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="../styles/style.css" /><title>A stack-based bytecode VM for Kombucha</title></head><body><p><a href="..#notes">Notes</a><br />2025/05/06</p><h1>A stack-based bytecode VM for Kombucha</h1><p>This weekly note is a bit less self-contained than most of the previous ones, as it is about implementing a simple bytecode virtual machine for the language I'm experimenting with, <a href="https://github.com/fkettelhoit/kombucha">Kombucha</a>. The VM is not particularly novel, so this note is more of a summary for me than an article with a central argument.</p><h2>Desugaring into lambda calculus</h2><p>All source code is first parsed, then desugared into a simple form that is similar to untyped lambda calculus. <a href="./2025-03-16.html">Explicit bindings</a> are desugared into normal lambda abstractions. Expressions can either be lambda calculus forms (variables with de Bruijn indices, lambda abstractions or lambda applications), <a href="./2025-03-01.html">string constants or recursion</a>, or one of two built-in primitives, <code>pop</code> or <code>if</code>:</p><pre><code>enum Expr {
    Var(usize), // variables (with de Bruijn indices)
    String(usize), // interned strings
    Abs(Box&lt;Expr&gt;), // lambda abstraction
    Rec(Box&lt;Expr&gt;), // recursion
    App(Box&lt;Expr&gt;, Box&lt;Expr&gt;), // lambda application
    Pop(Box&lt;Expr&gt;, Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    If(Box&lt;Expr&gt;, Box&lt;Expr&gt;, Box&lt;Expr&gt;, Box&lt;Expr&gt;),
}
</code></pre><p>Recursion binds a lambda abstraction to itself: While Abs(...) corresponds to a function x => ..., the expression Rec(Abs(...)) corresponds to the function x => ... where x is bound to that very function. This can be used to build recursive functions or values. For example, assuming that the string <code>Foo</code> is interned as String(0), the expression Rec(Abs(App(String(0), Var(0)))) would correspond to the infinite expansion App(Foo, App(Foo, App(Foo, ...))).</p><p>The primitive function <code>pop</code> can be used to destructure strings applied to other expressions. If x is App(y, z), the expression pop(x, f, g) will evluate to f applied to the arguments y and z (in other words App(App(f, y), z)). If x is not an application, pop(x, f, g) will evaluate to g applied to some nil-like value.</p><p>The primitive function <code>if</code> compares two strings for equality. If a and b in if(a, b, t, f) are the same interned strings, the expression will evaluate to t applied to some nil-like value, otherwise it will evaluate to f applied to some nil-like value.</p><h2>A stack-based VM</h2><p>Desugared expressions are then compiled into a list of bytecode instructions:</p><pre><code>enum Op {
    PushVar(usize /* index */),
    PushString(usize /* interned */),
    PushFn(usize /* code */, usize /* captured vars */),
    Rec, // bind the topmost value to itself
    Apply, // apply the two topmost values
    Return, // return from the current fn
    Pop,
    If,
}
</code></pre><p>The VM uses 3 stacks:</p><ul><li>A stack of variables, corresponding to function arguments: A function can access the variable with de Bruijn index 0 at the top of the variable stack, the variable with de Bruijn index 1 is one lower on the stack, etc.</li><li>A stack of temporaries, which are used for the operands and results of Rec, Apply, Return, Pop and If. A PushVar instruction copies a value from the variable stack and pushes it onto the stack of temporaries.</li><li>A stack of call frames, which store both how many captured variables a closure has pushed onto the variable stack (which will all be popped once the closure returns) and which instruction in the list of bytecodes should be used as the return address when the function / closure returns.</li></ul><p>Call frames are stored as pairs of unsigned numbers, whereas the stacks for variables and temporaries both store values, which are of the following form:</p><pre><code>pub enum V {
    Fn(usize, usize, usize),
    String(usize),
    Record(usize, Vec&lt;Rc&lt;V&gt;&gt;),
    Closure(usize, Rc&lt;Vec&lt;V&gt;&gt;),
    Recursive(usize, Rc&lt;Vec&lt;V&gt;&gt;),
}
</code></pre><p>All values start out as either Fns (which store their code pointer, the number of variables to capture and the call frame they belong to) or Strings (which store the index of the string in the interned string pool). When strings are applied to other values, they become Records, which store their applicands in a Vec. When Fns are not applied immediately but instead used as data (either as arguments of other functions or returned from their containing function) they capture the variables that they reference as a closure. (The compiler statically tracks how many variables a function might capture.) A Recursive value is a closure whose function argument is bound to itself.</p><p>Tracking the number of variables-to-capture as well as the call frame where a function originated allows the creation of closures to be avoided in many cases, because the current call frame (and an unchanged stack of variables) can just be reused if a function is applied directly. The idea is similar to <a href="https://www.lua.org/doc/jucs05.pdf">upvalues in Lua 5</a>, where values are only captured when a closure is returned from a function.</p><p>Right now there is no tail call optimization, but it should be possible to add it relatively easily by checking whether an Apply instruction is immediately followed by a Return, then reuse the current call frame if possible. This could even be checked statically, which would allow emitting a special TailReturn instruction, but it's probably just as easy to do it directly in the VM. (The opposite case, a Return followed by an Apply, which can be optimized so that no variables are captured unnecessarily in a closure, cannot be checked statically by the compiler, as only the VM is aware of the return address and thus the following instruction.)</p><h2>Unifying vars and temps using registers?</h2><p>Separating variables and temporaries into separate stacks turned out to be easier than trying to track the locations of variables using call frames and putting everything on a single stack, but still seems somewhat suboptimal, as a lot of variables are cloned and pushed onto the temp stack using PushVar instructions only to be immediately consumed by Rec / Apply / Pop / If instructions.</p><p>A possible alternative that I want to explore more might be a register-based approach which gets rid of the temp stack completely and uses a single stack for variables and values. PushVar instructions would completely fall away, Rec / Apply / Pop / If would directly specify their operands using indices pointing to variables on the stack.</p><p>Here's a sketch of how the instructions might change:</p><pre><code>enum Op {
    PushString(usize /* interned */),
    PushFn(usize /* code */, usize /* captured vars */),
    Rec(usize), // bind the topmost value to itself
    Apply(usize, usize), // apply the two topmost values
    Return, // return from the current fn
    Pop(usize, usize, usize),
    If(usize, usize, usize, usize),
}
</code></pre><footer>Want to become a better programmer? <a href="https://www.recurse.com/scout/click?t=764048f99cede394c1905c64e1545a5d">Join the Recurse Center!</a></footer></body></html>