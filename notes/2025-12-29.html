<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="../styles/style.css" /><title>Flat bytecode as lists and arrays</title></head><body><p><a href="..#notes">Notes</a><br />2025/12/29</p><h1>Flat bytecode as lists and arrays</h1><p>As outlined in a note on <a href="./2025-12-27.html">bytecode as a flat AST</a>, bytecode can be seen as a flat representation of tree-like data. A list of cons cells of the form <code>(x, (y, (z, ())))</code> could be represented as the following flat bytecode:</p><pre><code>x y z () CONS CONS CONS
</code></pre><p>When the bytecode is evaluated, we can either view it as a sequence of stack operations that manipulate a separate value representation (such as boxed cons lists), or we can view the bytecode as the value representation itself.</p><h2>Bytecode as lists</h2><p>However, using bytecode as the value representation has the disadvantage that we need to traverse the list from the end whenever we want to access an element of the list. Since <code>x</code>, <code>y</code>, or <code>z</code> could be represented as bytecode sequences of varying length, we need to read and traverse these child elements. In other words, we cannot easily skip over elements.</p><p>Such an approach is even worse in terms of time complexity than normal cons lists, because not only is accessing a random element <code>O(n)</code> in the size of the list, but each element has to be fully traversed as well. Is there a better bytecode representation? One that would give us <code>O(1)</code> array-like random access?</p><h2>Bytecode as arrays</h2><p>The easiest solution is to pad each element so that all elements have the same size and then store both the number of items and the size of individual items:</p><pre><code>// n = number of items
// m = max size of item
x y z () CONS&lt;n, m&gt;
</code></pre><p>Since a <code>CONS</code> instruction can now cons together multiple elements, we could additionally make the empty list <code>()</code> implicit and treat a <code>CONS</code> of 0 elements as the empty list:</p><pre><code>CONS&lt;0, m&gt;       // ()
x y z CONS&lt;3, m&gt; // (x, (y, (z, ())))
</code></pre><p>Could this be a viable runtime representation for a bytecode evaluator? At the very least, it sounds like an idea worth exploring to see where it breaks. At best, it might result in bytecode that supports efficient random access traversal.</p><footer>Want to become a better programmer? <a href="https://www.recurse.com/scout/click?t=764048f99cede394c1905c64e1545a5d">Join the Recurse Center!</a></footer></body></html>