<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="../styles/style.css" /><title>Radically simple structural types (with comptime)</title></head><body><p><a href="..#notes">Notes</a><br />2025/12/28</p><h1>Radically simple structural types (with comptime)</h1><p>Continuing my initial thoughts on <a href="./2025-11-30.html">Kombucha's type system</a>, I've been thinking more about how to build a type system that targets a slightly different point in the design space than most other languages:</p><p>I want to build a type system that is <em>radically simple</em> and gives me <em>some</em> static guarantees while <em>getting out of my way</em> so that the language still feels dynamically typed.</p><p>Most modern languages use type systems that are either extremely sophisticated (both in terms of implementation and use) or simple but restrictive (in the sense that they rely on nominal types and rarely support a combination of parametric polymorphism and subtyping).</p><p>Instead, I want something that feels closer to TypeScript: A type system that provides some static guarantees and catches most type errors, but without requiring nominal types and data type declarations. However, in contrast to TypeScript I don't want to support the maximum amount of dynamism and I want a type system that is much simpler to implement.</p><h2>Equi- or iso-recursive types?</h2><p>Recursive data types, such as cons lists or trees, need to be supported, so I need recursive types. Equi-recursive types are elegant but more complex in terms of implementation, which I would like to avoid. However, iso-recursive types require explicit <code>fold</code> / <code>unfold</code> operations, which are hard to insert automatically in the absence of nominal types and data type definitions.</p><p>I'm still wondering whether there is a notion that is of use in dynamic languages and that corresponds to iso-recursive types, so that <code>fold</code> / <code>unfold</code> would feel less like pointless ceremony and more like saying something meaningful? Is there value in distinguishing “folded” and “flat” data in a dynamically typed language?</p><h2>Just unions?</h2><p>I was originally planning to support both union types and (restricted) intersection types, but intersection types get complicated really fast. Maybe union types are enough? They are conceptually much simpler, well understood (and liked) in TypeScript, and much easier to implement.</p><p>Also, they are perfect for a type system that should feel structural (at the cost of being less precise), because they always allow you to “throw away” information and talk about a combination of base types.</p><h2>Comptime monomorphization instead of polymorphism?</h2><p>Parametric polymorphism (in other words, generics) adds a lot of complexity to a type system, starting with the need to unify type variables and generalize them to a type scheme at the right points. Ad-hoc polymorphism (in the style of type classes / traits) or bounded polymorphism (combining generics with subtyping) add even more complexity and subtle interactions.</p><p>Is it possible to sidestep this complexity completely, while still being able to type polymorphic functions like <code>map</code> and <code>filter</code>? Zig's approach of using comptime evaluation is unorthodox but interesting: Instead of trying to prove that a function is well-typed for <em>all</em> possible cases (using type variables), the function can be monomorphized using comptime evaluation and is then checked at each call site.</p><h2>Comptime type aliases?</h2><p>Comptime evaluation would also nicely solve the need for type aliases without requiring a new mini language: Instead, type aliases are just functions that are evaluated at compile time and that return types (without type aliases and without type variables).</p><p>Using comptime as a replacement for these advanced type system features might sometimes be less efficient (because it requires checking a type at several call sites), but then again HM type inference has exponential time complexity in the worst case as well. Who knows, the added overhead of comptime monomorphization might not matter that much in practice.</p><p>Using comptime to evaluate away polymorphism before type checking is a hack, but it sounds like a hack that is worth exploring.</p><footer>Want to become a better programmer? <a href="https://www.recurse.com/scout/click?t=764048f99cede394c1905c64e1545a5d">Join the Recurse Center!</a></footer></body></html>