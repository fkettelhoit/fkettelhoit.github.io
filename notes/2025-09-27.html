<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="../styles/style.css" /><title>RC week 19: a sketch for a time loop calculus</title></head><body><p><a href="..#notes">Notes</a><br />2025/09/27</p><h1>RC week 19: a sketch for a time loop calculus</h1><p>This is a continuation of the notes from <a href="./2025-09-13.html">two weeks ago</a> and <a href="./2025-09-20.html">last week</a> about paradoxical solutions for recursive loops that show similarities to the halting problem.</p><p>Briefly, the idea is to extend a minimal programming language with values that are “oscillating” so that they conceptually represent multiple values <em>at the same time.</em> This is useful for resolving <em>fixed points</em> of functions, allowing us to find a value <code>v</code> that equals <code>f(v)</code> for the following function <code>f</code>:</p><pre><code>def f(v):
    if v == &apos;x&apos;:
        &apos;y&apos;
    else:
        &apos;x&apos;
</code></pre><p>Notice that <code>f</code> shows a similar structure to the liar's paradox: If the value is <code>'x'</code>, the function returns <code>'y'</code>, but if the value is <code>'y'</code>, the function returns <code>'x'</code>, which makes it impossible to come up with a (terminating) value <code>v</code> that equals <code>f(v)</code>.</p><p>Here's a sketch for a minimal calculus that supports paradoxical values in the form of sequences of values that loop back to the original value.</p><h2>Time loops</h2><p>The main idea is simple: If a function such as <code>f</code> above turns <code>'x'</code> into <code>'y'</code> and then <code>'y'</code> into <code>'x'</code>, why not represent a paradoxical fixed point solution for <code>f</code> as a sequence of steps before the value loops again?</p><p>Let's write such a value as <code>['x'; 'y']</code>, which stands for “first <code>'x'</code>, then <code>'y'</code>” (then back to the start). Such a sequence is called a “time loop sequence” (or just “time loop” for short). Since such a sequence is a loop, it represents the sequence <code>'x'</code>, <code>'y'</code>, <code>'x'</code>, <code>'y'</code>, <code>'x'</code>, <code>'y'</code>, and so forth. But even though it conceptually “extends” forever, the starting point matters and <code>['x'; 'y']</code> is <em>not</em> the same value as <code>['y'; 'x']</code>.</p><p>Time loops extend program execution with a notion of discrete time steps: The time loop <code>['x'; 'y']</code> can be thought of as a value that is <code>'x'</code> at step 0, <code>'y'</code> at step 1, <code>'x'</code> at step 2, <code>'y'</code> at step 3, and so forth. The value “oscillates” without any need (nor possibility) to iterate manually through the sequence.</p><p>Such a time loop is not a list: It is not possible to inspect the length of a time loop, nor is it possible to append a value to a list or use other list-like operations. From the perspective of the language, a time loop is just a single value, which allows us to use it in a comparison such as <code>['x'; 'y'] == 'x'</code>.</p><h2>Comparing time loops</h2><p>How can a time loop such as <code>['x'; 'y']</code> be compared to an atomic value such as <code>'x'</code>? Since <code>['x'; 'y']</code> represents a value that is <code>'x'</code> at step 0, <code>'y'</code> at step 1, and so forth, we can think of atomic values like <code>'x'</code> as a sort of time loop that always has the same value: <code>'x'</code> at step 0, <code>'x'</code> at step 1, and so forth. Now we can evaluate <code>['x'; 'y'] == 'x'</code> by matching up these values, which will give us <code>true</code> at step 0, <code>false</code> at step 1, <code>true</code> at step 2, <code>false</code> at step 3, and so forth, which we can represent as <code>[true; false]</code>.</p><p>Using such a time-looped boolean value in a conditional follows the same approach. Let's use <a href="https://en.wikipedia.org/wiki/Church_encoding#Church_Booleans">Church encoding</a>, allowing us to define <code>true</code> as the function <code>(x, y) => x</code> and <code>false</code> as the function <code>(x, y) => y</code>. The <code>if-else</code> construct is then just sugar and <code>if-else(p, t, f)</code> stands for <code>p(t, f)</code>. To evaluate <code>if [true; false]: 'y' else: 'x'</code> we thus need to evaluate <code>[true; false]('y', 'x')</code>.</p><p>We can now again view atomic values conceptually as time loops with the same value at each step and perform function application by “zipping” together the time-looped function with its argument, giving us the following:</p><pre><code>if [true; false]:
    &apos;y&apos;
else:
    &apos;x&apos;
# --&gt;
[true; false](&apos;y&apos;, &apos;x&apos;)
# --&gt;
[true; false]([&apos;y&apos;; &apos;y&apos;], [&apos;x&apos;; &apos;x&apos;])
# --&gt;
[true(&apos;y&apos;, &apos;x&apos;); false(&apos;y&apos;, &apos;x&apos;)]
# --&gt;
[&apos;y&apos;; &apos;x&apos;]
</code></pre><p>We have now seen how we can go from <code>f(['x'; 'y'])</code> to <code>['y'; 'x']</code>. This is <em>almost</em> what we want: It is the value that we started with, except that it is shifted by one position in the time loop. This makes sense, because applying the function “took a step” and we ended up with a value that is just like the original time loop, except shifted by one step.</p><p>For now, we will leave aside the question when and how time loops get shifted back (so that we get true fixed points) and instead first look at how time loops behave in more interesting examples.</p><h2>Lifting nested loops</h2><p>What happens if we use a time loop as part of <code>f</code>?</p><pre><code>def f(v):
    if v == [&apos;x&apos;; &apos;y&apos;]:
        &apos;y&apos;
    else:
        &apos;x&apos;
</code></pre><p>The time loop <code>['x'; 'y']</code> cannot be a fixed point of <code>f</code>, because the comparison would evaluate to <code>[true; true]</code>, which is equivalent to <code>[true]</code>, so <code>f(['x'; 'y'])</code> would return <code>['y']</code>. We need something <em>stronger</em> than just a single time loop, something that can express that <code>['x'; 'y']</code> returns <code>['y']</code> and that <code>['y']</code> returns <code>['x'; 'y']</code>, thus closing the loop. In other words, we need a <em>nested</em> time loop: <code>[['x'; 'y']; ['y']]</code></p><p>To be able to “package together” time loops as fixed points, we need to ensure that a comparison such as <code>[['x'; 'y']; ['z']] == ['a'; 'b']</code> compares <code>['x'; 'y']</code> with <code>['a'; 'b']</code>, then <code>['y']</code> with <code>['a'; 'b']</code>, <em>not</em> <code>['x'; 'y']</code> with <code>'a'</code>, then <code>['y']</code> with <code>'b'</code>. In other words, we need to ensure that the <code>['a'; 'b']</code> on the right is <em>lifted</em> into the nested time loop on the left instead of zipping together the two sides immediately.</p><p>To achieve this, let's add a notion of <em>depth</em> to time loops. An atomic value like <code>'x'</code> has a depth of 0, a time loop like <code>['x'; 'y']</code> has a depth of 1, a time loop like <code>[['x'], ['x'; 'y']]</code> has a depth of 2, etc. The depth <code>depth([s; t])</code> for arbitrary <code>s</code> and <code>t</code> is defined as <code>max(depth(s), depth(t)) + 1</code>.</p><p>Two time loops are only zipped together if they have the same depth. Otherwise, each element of the time loop with the greater depth is compared to the full time loop with the smaller depth.</p><pre><code>[[&apos;x&apos;; &apos;y&apos;]; [&apos;y&apos;]] == [&apos;x&apos;; &apos;y&apos;]
# --&gt;
[[&apos;x&apos;; &apos;y&apos;] == [&apos;x&apos;; &apos;y&apos;]; [&apos;y&apos;] == [&apos;x&apos;; &apos;y&apos;]]
# --&gt;
[[true; true]; [false; true]]
# --&gt;
[[true]; [false; true]]
</code></pre><p>This ensures that reasoning about the fixed points of a function using a case-by-case analysis remains <em>compositional,</em> because the different cases can then be bundled together in a nested time loop, without changing how individual elements behave as arguments to the function.</p><h2>Combining time loops</h2><p>Time loops also make it easy to combine different subexpressions that all depend on the fixed point of a function. Let's take the following function as an example:</p><pre><code>def f(v):
    if v == &apos;x&apos;:
        &apos;y&apos;
    else:
        if v == &apos;x&apos;:
            &apos;z&apos;
        else:
            &apos;x&apos;
</code></pre><p>As always, the task is to find a fixed point <code>v</code> so that <code>v</code> equals <code>f(v)</code>, but now the additional challenge is that we would like to be able to reason about both uses of <code>v</code> independently. The inner conditional is just a regular liar, so <code>['x'; 'z']</code> would be a solution for the inner part. But the outer conditional would turn <code>['x'; 'z']</code> into <code>['x'; 'y']</code>, so we need a solution that is true for the outer <em>and</em> inner conditional at the same time.</p><p>Luckily, the fact that all time loops follow the same conceptual clock makes this pretty easy. <code>['x'; 'y']</code> is a fixed point for <code>f</code>, because at time step 0 (in the <code>'x'</code> case) only the then-branch of the outer conditional is relevant, while at time step 1 (in the <code>'y'</code> case) only the else-branch of the inner conditional is relevant. In other words, even though the value <code>['x'; 'y']</code> is used in two places, the sequences are synchronized and the then-branch of the inner conditional is never visited. We can thus simplify the above function:</p><pre><code>def f(v):
    if v == &apos;x&apos;:
        &apos;y&apos;
    else:
        &apos;x&apos;
</code></pre><p>The synchronization of time steps ensures that we can reason about fixed points compositionally and that most standard ways of simplifying conditionals according to non-paradoxical boolean logic still apply.</p><h2>Shifting time loops</h2><p>We can now return to the question of when and how to shift time loops. All of the above solutions aren't technically fixed points, because applying the above functions to the proposed time loops gets us <em>shifted</em> versions of the function arguments: <code>['x'; 'y']</code> becomes <code>['y'; 'x']</code>, <code>['x'; 'y'; 'z']</code> becomes <code>['y'; 'z'; 'x']</code>, etc.</p><p>What is still missing is a way to shift back time loops after “time has passed”, which means after a function has been fully applied. This is not as trivial as it sounds, because function application can be a multi-step process in the presence of currying and the evaluation rules need to ensure that a time loop is shifted by a single position after all functions have been fully applied.</p><p>How this is best done is still a work in progress. For now, the above sketch of the time loops calculus leads to fixed points that are <em>almost,</em> but not <em>quite</em> right.</p><footer>Want to become a better programmer? <a href="https://www.recurse.com/scout/click?t=764048f99cede394c1905c64e1545a5d">Join the Recurse Center!</a></footer></body></html>