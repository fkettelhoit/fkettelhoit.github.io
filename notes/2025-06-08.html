<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="../styles/style.css" /><title>RC week 3: a gentle introduction to Kombucha</title></head><body><p><a href="..#notes">Notes</a><br />2025/06/08</p><h1>RC week 3: a gentle introduction to Kombucha</h1><p><a href="./2025-05-24.html">Kombucha</a> is a minimal and malleable programming language, which I'm building during my 12 weeks at the <a href="https://www.recurse.com/">Recurse Center</a>. Here's what it looks like:</p><h2>Comments</h2><p>Comments start with // and end at the end of the line.</p><pre><code>// This is a comment.
</code></pre><h2>Strings + atoms</h2><p>The only basic data type that Kombucha provides are strings. Strings might be composite data types in other languages, but from the perspective of Kombucha each string is an <em>atomic value:</em> You can check whether one string is equal to another, but there are no operations to manipulate strings. (Kombucha strings are interned, just like symbols in Ruby, atoms in Elixir and keywords in Clojure.)</p><p>There are two string-like data types:</p><pre><code>// Strings are wrapped in double quotes:

&quot;a string&quot;
#&quot;raw strings can contain &quot; characters&quot;#
##&quot;this raw string contains a #&quot; in the string&quot;##

// Capitalized identifiers are string-like atoms:
Foo
BarBaz
</code></pre><p>While <code>Foo</code> and <code>"Foo"</code> are both represented as strings under the hood, they are different values. Uppercase identifiers are called atoms, double-quoted strings are just called strings.</p><h2>Compounds</h2><p>Strings and atoms can be applied to each other to form ad-hoc compound data structures without the need to define any types beforehand. An atom Foo applied to the two atoms <code>X</code> and <code>Y</code> can be thought of as a <em>record</em> Foo with two positional fields holding the atoms <code>X</code> and <code>Y</code>.</p><pre><code>// A record Foo containing X and Y:
Foo(X, Y)

// A Pair of two other records:
Pair(Section(X, Y), Paragraph(Z))
</code></pre><h2>Lists</h2><p>The empty atom is written <code>[]</code> and represents an empty list. Lists of values can be built by successively applying <code>[]</code> to values, <em>with the first value of the list as the last applied value:</em></p><pre><code>[Foo, Bar, Baz] // ...is the same as:
[](Baz, Bar, Foo) // ...which is the same as:
(([](Baz))(Bar))(Foo)
</code></pre><h2>Functions</h2><p>Function names start with non-uppercase ASCII characters (otherwise they would be atoms). Here's an example of a function <code>f</code> being applied to the two atoms <code>Foo</code> and <code>Bar</code>:</p><pre><code>f(Foo, Bar)
</code></pre><p>Functions can also be applied using infix notation:</p><pre><code>Foo f Bar // ...is the same as f(Foo, Bar)
</code></pre><p>Every function can be applied using infix notation. All infix functions have the same precedence and it is invalid to use different infix functions in the same expression without grouping their parts using <code>(...)</code>.</p><pre><code>(X f Y) g Z // ...is ok, but X f Y g Z would be invalid.
X f Y f Z   // ...is ok and parsed as (X f Y) f z.
</code></pre><p>Kombucha supports a third way of calling functions, keyword calls, which are especially useful for control structures (which are just regular functions in Kombucha). A function named <code>foo-bar-baz</code> can be called as <code>foo: arg1 bar: arg2 baz: arg3</code>, which Kombucha will splice together as <code>foo-bar-baz(arg1, arg2, arg3)</code>.</p><pre><code>foo: X bar: Y baz: Z // ...is the same as foo-bar-baz(X, Y, Z)
foo: X bar: Y        // ...is the same as foo-bar(X, Y)
foo: Bar             // ...is the same as foo(Bar)
</code></pre><p>This means that a single argument function <code>f(x)</code> can always be called as <code>f: X</code>.</p><p>Nested keyword calls must be grouped using <code>(...)</code>:</p><pre><code>foo: (bar: X baz: Y) qux: Z
</code></pre><p>Lastly, <code>f(x, y, z)</code> is just sugar for <code>((f(x))(y))(z)</code>, in other words <code>f(x, y, z)</code> is sugar for <em>currying</em>, the repeated application of a function to a single argument.</p><h2>Variables + bindings</h2><p>All variables start with non-uppercase ASCII characters (otherwise they would be atoms). A variable can be assigned using the = function, which expects a <em>binding</em>, which is the name of a variable prefixed with <code>:</code>. Here's an example:</p><pre><code>:x = Foo // Assigns the atom Foo to the variable x.
:y = x   // Assigns the value of the variable x to the variable y.
</code></pre><p>Why does Kombucha distinguish bindings and variables instead of just using <code>y = x</code> like other languages? In Kombucha, the <code>=</code> function is just a regular function and the <code>:x</code> syntax signals that <code>x</code> is not being <em>used</em>, it is being <em>bound</em>. This might look superfluous here, but will come in handy later on.</p><h2>Blocks</h2><p>New function can be defined using the <code>=></code> function, which binds one or more variables on the left-hand side to a function body enclosed in <code>{...}</code> on the right-hand side:</p><pre><code>:x =&gt; { f(x) }          // A single argument function with body f(x).
[:x, :y] =&gt; { f(x, y) } // A function of two arguments x and y.
</code></pre><p>The <code>{...}</code> part is called a <em>block</em> and can contain variable definitions separated by commas or newlines. A block always evaluates to the last expression in the block:</p><pre><code>:x =&gt; {
    :y = f(x)
    :z = g(y, y)
    Pair(z, z) // This is the return value of the function.
}
</code></pre><p>A Kombucha program is a collection of expressions that are implicitly wrapped in <code>{...}</code>.</p><h2>Recursion</h2><p>Recursive functions can be built using the <code>~></code> function, which binds a variable to itself:</p><pre><code>:f ~&gt; {
    // Inside of this block, f is bound to itself.
    [:x, :y] =&gt; {
        f(x, y) // This will call f recursively (and never terminate).
    }
}
</code></pre><h2>Pattern matching</h2><p>Apart from <code>=</code>, <code>=></code> and <code>~></code>, the most useful function provided by Kombucha are the pattern matching functions <code>-></code> and <code>match-with</code>:</p><pre><code>// match: ... with: ... is a keyword call for match-with
match: x with: [
    Foo(Bar, Baz) -&gt; { &quot;just Foo(Bar, Baz)&quot; }
    Foo(:x, :x) -&gt; { twice(x) }
    Foo(:x, y) -&gt; { &quot;the second element is the value of y&quot; }
]
</code></pre><p>Notice how <code>y</code> is used as a <em>value</em>, not as a <em>binding</em>. The last clause of the pattern match only succeeds if the second element of <code>Foo</code> has the value <code>y</code>, whereas the first element of Foo is <em>bound</em> to the variable <code>x</code>, not matter what the element's value is.</p><h2>Effects</h2><p>What happens when no pattern matches the value? This is an example of an <em>effect</em>, which is like an exception that can be resumed by its exception handler (if desired). Effects look like function names, but always end with <code>!</code> and do not need to defined before being used. What happens when an effect is called depends on which <em>effect handler</em> has been (dynamically) installed. If there is no effect handler, the execution will stop and the effect will bubble up all the way to the (Rust) host, which can then handle the effect and resume the execution.</p><pre><code>// This will bubble up to the Rust host:
throw!(&quot;throwing something without a handler&quot;)

// This will evaluate to Bar(Twice(x, x)):
try: {
  match: x with: [
    Pair(:x, :x) -&gt; {
      Foo(Twice(x, x))
    }
    :value -&gt; {
      // The not-equal! effect will be handled.
      Bar(not-equal!(value))
    }
  ]
} catch: not-equal! as: [:resume, :arg] =&gt; {
  // We handle it by resuming execution:
  resume(Twice(arg, arg))
}
</code></pre><h2>Commas and newlines</h2><p>One last thing to point out is that commas and newlines are completely interchangeable in Kombucha. Every <code>(...)</code>, <code>[...]</code> and <code>{...}</code> can contain one or more commas/newlines before and after each element (including leading or trailing commas/newlines), but elements must be separated by at least one comma or newline.</p><pre><code>// [Foo, Bar]
[
    Foo
    Bar
]

// f(Foo, Bar)
f(
  Foo
  Bar
)

// { :x = Foo, :y = Bar }
{
  :x = Foo
  :y = Bar
}
</code></pre><p>Commas/newlines are <em>not</em> allowed immediately after keywords ending in <code>:</code>.</p><footer>Want to become a better programmer? <a href="https://www.recurse.com/scout/click?t=764048f99cede394c1905c64e1545a5d">Join the Recurse Center!</a></footer></body></html>