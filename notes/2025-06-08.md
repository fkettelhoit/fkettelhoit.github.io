# RC week 3: a gentle introduction to Kombucha

[Kombucha](./2025-05-24.html) is a minimal and malleable programming language, which I'm building during my 12 weeks at the [Recurse Center](https://www.recurse.com/). Here's what it looks like:

## Comments

Comments start with // and end at the end of the line.

```
// This is a comment.
```

## Strings + atoms

The only basic data type that Kombucha provides are strings. Strings might be composite data types in other languages, but from the perspective of Kombucha each string is an _atomic value:_ You can check whether one string is equal to another, but there are no operations to manipulate strings. (Kombucha strings are interned, just like symbols in Ruby, atoms in Elixir and keywords in Clojure.)

There are two string-like data types:

```
// Strings are wrapped in double quotes:

"a string"
#"raw strings can contain " characters"#
##"this raw string contains a #" in the string"##

// Capitalized identifiers are string-like atoms:
Foo
BarBaz
```

While `Foo` and `"Foo"` are both represented as strings under the hood, they are different values. Uppercase identifiers are called atoms, double-quoted strings are just called strings.

## Compounds

Strings and atoms can be applied to each other to form ad-hoc compound data structures without the need to define any types beforehand. An atom Foo applied to the two atoms `X` and `Y` can be thought of as a _record_ Foo with two positional fields holding the atoms `X` and `Y`.

```
// A record Foo containing X and Y:
Foo(X, Y)

// A Pair of two other records:
Pair(Section(X, Y), Paragraph(Z))
```

## Lists

The empty atom is written `[]` and represents an empty list. Lists of values can be built by successively applying `[]` to values, _with the first value of the list as the last applied value:_

```
[Foo, Bar, Baz] // ...is the same as:
[](Baz, Bar, Foo) // ...which is the same as:
(([](Baz))(Bar))(Foo)
```

## Functions

Function names start with non-uppercase ASCII characters (otherwise they would be atoms). Here's an example of a function `f` being applied to the two atoms `Foo` and `Bar`:

```
f(Foo, Bar)
```

Functions can also be applied using infix notation:

```
Foo f Bar // ...is the same as f(Foo, Bar)
```

Every function can be applied using infix notation. All infix functions have the same precedence and it is invalid to use different infix functions in the same expression without grouping their parts using `(...)`.

```
(X f Y) g Z // ...is ok, but X f Y g Z would be invalid.
X f Y f Z   // ...is ok and parsed as (X f Y) f z.
```

Kombucha supports a third way of calling functions, keyword calls, which are especially useful for control structures (which are just regular functions in Kombucha). A function named `foo-bar-baz` can be called as `foo: arg1 bar: arg2 baz: arg3`, which Kombucha will splice together as `foo-bar-baz(arg1, arg2, arg3)`.

```
foo: X bar: Y baz: Z // ...is the same as foo-bar-baz(X, Y, Z)
foo: X bar: Y        // ...is the same as foo-bar(X, Y)
foo: Bar             // ...is the same as foo(Bar)
```

This means that a single argument function `f(x)` can always be called as `f: X`.

Nested keyword calls must be grouped using `(...)`:

```
foo: (bar: X baz: Y) qux: Z
```

Lastly, `f(x, y, z)` is just sugar for `((f(x))(y))(z)`, in other words `f(x, y, z)` is sugar for _currying_, the repeated application of a function to a single argument.

## Variables + bindings

All variables start with non-uppercase ASCII characters (otherwise they would be atoms). A variable can be assigned using the = function, which expects a _binding_, which is the name of a variable prefixed with `:`. Here's an example:

```
:x = Foo // Assigns the atom Foo to the variable x.
:y = x   // Assigns the value of the variable x to the variable y.
```

Why does Kombucha distinguish bindings and variables instead of just using `y = x` like other languages? In Kombucha, the `=` function is just a regular function and the `:x` syntax signals that `x` is not being _used_, it is being _bound_. This might look superfluous here, but will come in handy later on.

## Blocks

New function can be defined using the `=>` function, which binds one or more variables on the left-hand side to a function body enclosed in `{...}` on the right-hand side:

```
:x => { f(x) }          // A single argument function with body f(x).
[:x, :y] => { f(x, y) } // A function of two arguments x and y.
```

The `{...}` part is called a _block_ and can contain variable definitions separated by commas or newlines. A block always evaluates to the last expression in the block:

```
:x => {
    :y = f(x)
    :z = g(y, y)
    Pair(z, z) // This is the return value of the function.
}
```

A Kombucha program is a collection of expressions that are implicitly wrapped in `{...}`.

## Recursion

Recursive functions can be built using the `~>` function, which binds a variable to itself:

```
:f ~> {
    // Inside of this block, f is bound to itself.
    [:x, :y] => {
        f(x, y) // This will call f recursively (and never terminate).
    }
}
```

## Pattern matching

Apart from `=`, `=>` and `~>`, the most useful function provided by Kombucha are the pattern matching functions `->` and `match-with`:

```
// match: ... with: ... is a keyword call for match-with
match: x with: [
    Foo(Bar, Baz) -> { "just Foo(Bar, Baz)" }
    Foo(:x, :x) -> { twice(x) }
    Foo(:x, y) -> { "the second element is the value of y" }
]
```

Notice how `y` is used as a _value_, not as a _binding_. The last clause of the pattern match only succeeds if the second element of `Foo` has the value `y`, whereas the first element of Foo is _bound_ to the variable `x`, not matter what the element's value is.

## Effects

What happens when no pattern matches the value? This is an example of an _effect_, which is like an exception that can be resumed by its exception handler (if desired). Effects look like function names, but always end with `!` and do not need to defined before being used. What happens when an effect is called depends on which _effect handler_ has been (dynamically) installed. If there is no effect handler, the execution will stop and the effect will bubble up all the way to the (Rust) host, which can then handle the effect and resume the execution.

```
// This will bubble up to the Rust host:
throw!("throwing something without a handler")

// This will evaluate to Bar(Twice(x, x)):
try: {
  match: x with: [
    Pair(:x, :x) -> {
      Foo(Twice(x, x))
    }
    :value -> {
      // The not-equal! effect will be handled.
      Bar(not-equal!(value))
    }
  ]
} catch: not-equal! as: [:resume, :arg] => {
  // We handle it by resuming execution:
  resume(Twice(arg, arg))
}
```

## Commas and newlines

One last thing to point out is that commas and newlines are completely interchangeable in Kombucha. Every `(...)`, `[...]` and `{...}` can contain one or more commas/newlines before and after each element (including leading or trailing commas/newlines), but elements must be separated by at least one comma or newline.

```
// [Foo, Bar]
[
    Foo
    Bar
]

// f(Foo, Bar)
f(
  Foo
  Bar
)

// { :x = Foo, :y = Bar }
{
  :x = Foo
  :y = Bar
}
```

Commas/newlines are _not_ allowed immediately after keywords ending in `:`.
